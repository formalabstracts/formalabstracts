import .basic ..data.dvector

/- Some definitions for specifying normal subgroups generated by group elements and by defining a group by generators and relations -/

open quotient_group set
open category_theory (mk_ob)

variables {α : Type*} [group α]

/-- the subgroup generated by a set is a normal subgroup if the set is closed under conjugates -/
lemma closure.normal_subgroup {s : set α} (hs : ∀ n ∈ s, ∀ g : α, g * n * g⁻¹ ∈ s) : 
  normal_subgroup (group.closure s) := 
begin
  fapply normal_subgroup.mk, intros n H g, induction H,
  { constructor, apply hs _ H_a_1 },
  { simp, apply group.in_closure.one },
  { have := group.in_closure.inv (H_ih), simp only [mul_inv_rev, inv_inv] at this, 
    rwa [mul_assoc] },
  { have := group.in_closure.mul (H_ih_a) (H_ih_a_1), 
    rwa [mul_assoc, ←mul_assoc g⁻¹, inv_mul_cancel_left, ←mul_assoc, mul_assoc g] at this },
end

/-- The smallest set containing s closed under conjugations -/
inductive conjugates (s : set α) : set α
| base : Π{{x}}, x ∈ s → conjugates x
| normal : Π{{x}} y, conjugates x → conjugates (y * x * y⁻¹)

/-- Given a set s of group elements, return the normal subgroup of α generated by s. 
  This is called the conjugate closure, normal closure or the normal subgroup generated by s. -/
def normal_closure (s : set α) : set α :=
group.closure (conjugates s)

instance (s : set α) : normal_subgroup (normal_closure s) := 
closure.normal_subgroup $ λ x hx y, conjugates.normal y hx

def group_modulo_relations (α : Type*) [group α] (s : set α) : Group :=
mk_ob $ quotient_group.quotient (normal_closure s)
 
notation α `/⟪`:95 R `⟫`:90 := group_modulo_relations α R

def group_of_generators_relations (gen : Type*) (relations : set (free_group gen)) : Group := 
(free_group gen)/⟪relations⟫

notation `⟪`:95 G `|`:90 R`⟫`:0 := group_of_generators_relations G R

def generated_of {G : Type*} {R : set (free_group G)} : G → ⟪G | R⟫ :=
  λ g, by {apply mk, exact free_group.of g}

local notation `⟪`:50 a `⟫`:50 := free_group.of a

/- The dihedral groups -/

/- The dihedral groups are an easy case of the Coxeter groups -/
namespace dihedral_group
def r := ⟪ff⟫
def s := ⟪tt⟫
end dihedral_group
open dihedral_group

/-- The dihedral group of order 2n -/
def dihedral_group (n : ℕ) : Group := ⟪bool | {r^n, s^2, s * r * s * r}⟫

/-- The Coxeter group is the group with presentation ⟨ r_1, ... r_n | (r_ir_j)^{m_{i,j}} = 1 ⟩ 
If m_{i,j} = ∞, then no relation is imposed on r_ir_j. -/
-- Note: we currently don't require that m i i = 1 for all i, and that m i j ≥ 2 for i ≠ j.
def coxeter_group {α : Type*} (m : α → α → enat) : Group := 
⟪α | set.range (λ(x : α × α), (⟪x.1⟫ * ⟪x.2⟫)^m x.1 x.2) ⟫

def matrix_of_graph {α : Type*} [decidable_eq α] (E : α → α → Prop) [decidable_rel E] (x y : α) :
  enat :=
if x = y then 1 else if E x y then 3 else 2

/- Annotated graphs for generalized Coxeter-type presentations (see xviii of the atlas) -/
structure annotated_graph :=
  (vertex : Type*)
  (edge : vertex → vertex → Prop)
  (annotation : Π{{x y}}, edge x y → ℕ+)

/-- Turn a binary relation on a type into an annotated graph.
  By default, all edges are annotated with 3. -/
def annotated_graph_of_graph {α : Type*} (E : α → α → Prop) : annotated_graph :=
{ vertex := α,
  edge := E,
  annotation := λ _ _ _, 3}

/- Note: this scheme does not handle the possibility of loops. But I don't think we need that case. -/
def matrix_of_annotated_graph (Γ : annotated_graph) [decidable_eq Γ.vertex] [decidable_rel Γ.edge] (x y : Γ.vertex) :  enat :=
  if x = y then 1 else dite (Γ.edge x y) (λ h, Γ.annotation h) (λ _, 2)

/-- "annotate Γ (a,b) n" returns an annotated graph Γ' which is identical to Γ, except that Γ'.annotation a b = n. -/
def annotate (Γ : annotated_graph) [decidable_rel Γ.edge] [decidable_eq Γ.vertex] (x : Γ.vertex × Γ.vertex) (n : ℕ+) : annotated_graph :=
{ vertex := Γ.vertex,
  edge := Γ.edge,
  annotation := λ a b H, if (a = x.1 ∧ b = x.2) ∨ (a = x.2 ∧ b = x.1) then n else Γ.annotation H }

/- Coxeter Y-diagrams -/
@[derive decidable_eq] inductive coxeter_vertices {n} (xs : dvector ℕ n) : Type
| torso : coxeter_vertices
| arm : ∀ x : dfin n, dfin (xs.nth'' x + 1) → coxeter_vertices

open coxeter_vertices

inductive coxeter_edges_directed {n} (xs : dvector ℕ n) : 
  coxeter_vertices xs → coxeter_vertices xs → Prop 
| edge_torso : ∀ i : dfin n , coxeter_edges_directed (arm i dfin.fz) (torso _)
| edge_arm : ∀ i : dfin n, ∀ v : dfin (xs.nth'' i + 1), v ≠ dfin.last _ → 
    coxeter_edges_directed (arm i v) (arm i (v+1)) 

inductive symmetric_closure {α : Type*} (E : α → α → Prop) : α → α → Prop
| incl : ∀ a b : α, E a b → symmetric_closure a b
| symm : ∀ a b : α, E a b → symmetric_closure b a

def coxeter_edges {n} (xs : dvector ℕ n) : coxeter_vertices xs → coxeter_vertices xs → Prop :=
symmetric_closure (coxeter_edges_directed xs)

-- TODO derive decidability instances
noncomputable instance decidable_coxeter_edges {n} (xs : dvector ℕ n) : 
  decidable_rel $ coxeter_edges xs :=
λ _ _, classical.prop_decidable _

noncomputable instance decidable_annotated_coxeter_edges {n} (xs : dvector ℕ n) : decidable_rel $ (annotated_graph_of_graph (coxeter_edges xs)).edge :=
λ _ _, classical.prop_decidable _

noncomputable instance decidable_annotate_of_decidable (Γ : annotated_graph) [decidable_eq Γ.vertex] [decidable_rel Γ.edge] (x n) : decidable_rel $ (annotate Γ x n).edge := λ _ _, classical.prop_decidable _

/- Derived subgroups -/

def commutator {α : Type*} [group α] : α × α → α
| ⟨x, y⟩ :=  x * y * x⁻¹ * y⁻¹

notation `⟦`:95 x `,` y `⟧`:0 := commutator (x,y)

def commutators_of {α : Type*} [group α] (s : set α) : set α :=
group.closure $ commutator '' s.prod s

/-- the derived subgroup of commutator subgroup is the subgroup generated by all commutators -/
def derived_subgroup (α : Type*) [group α] : set α :=
commutators_of set.univ

instance (α : Type*) [group α] : normal_subgroup (derived_subgroup α) :=
begin
  apply closure.normal_subgroup, intros x hx g, rcases hx with ⟨⟨y, z⟩, h, rfl⟩, 
  use ⟨g * y * g⁻¹, g * z * g⁻¹⟩, 
  split, split; trivial,
  simp [commutator, mul_assoc]
end

/-- The n-th derived subgroup is defined by iterating the derived subgroup operation -/
def iterated_derived_subgroup (α : Type*) [group α] (n : ℕ) : set α :=
nat.iterate commutators_of n set.univ

/-- the abelianization of G is the group G quotiented by its derived subgroup -/
def abelianization (α : Type*) [group α] : Group :=
mk_ob $ quotient_group.quotient $ derived_subgroup α

/-- A group is called perfect if its derived subgroup is the whole group -/
def is_perfect (α : Type*) [group α] : Prop := derived_subgroup α = set.univ

/-- A group is called perfect if its derived subgroup is the whole group -/
def is_solvable (α : Type*) [group α] : Prop := ∃ n, iterated_derived_subgroup α n = {1}
